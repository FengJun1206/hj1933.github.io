<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2018%2F01%2F03%2F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数函数可以将程序拆分成独立的几部分，使程序趋于简单化。 1.1、定义和调用函数使用关键字def 来告诉python定义一个函数，向python指出了函数名，也还可以在括号内指出函数为完成任务需要什么样的信息。 而调用一个函数，只需让python指定函数名以及括号内的必要信息即可。 12345678910def display_message(): # 函数定义 """display a message about what I am learning.""" # 文档字符串的注释，描述函数是做什么的，由三引号组成，python用来生成有关程序中函数的文档 msg = "I'm learning to store code in functions." print(msg)display_message() # 函数调用----------I'm learning to store code in functions. 1.1.1、向函数参数传递信息函数在定义时，可在括号内指定任意参数，在调用时再给其指定一个值，调用函数时，可将值传递给参数： 1234567def great_user(username): # 指定参数（形参） print('Hello ' + username.title() + '!')great_user('edward') # 指定值并传递给参数（实参）-------Hello Edward! 1.1.2、形参和实参在1.1.1中，变量username是一个形参，它是函数定义时括号内的参数，是函数完成其工作所需的一项信息。 值’edward’ 是一个实参，它是函数调用时括号内的参数，是调用函数时传递给函数的信息。 在great_user（’edward’）中，将参数edward传递给函数great_user（），并存储在形参user_name中。 1.2、传递实参函数定义可能包含多个形参，调用时也可以有多个实参，传递实参的方式很多，有位置参数法，（要求形参实参的顺序一致）意义，关键字参数。 1.2.1、位置实参位置实参要求实参与形参的顺序一一对应,切记不能对应错误，另一方面，一个函数可以多次调用，只需再次指定实参即可。 12345678def describe_pet(animal_type, pet_name): """显示宠物信息""" print('\nI have a ' + animal_type + '.') print("My " + animal_type + "'s name is " + pet_name.title() + '.')describe_pet('hamster', 'harry') # 实参与形参顺序对应，宠物种类对应animal_type、名字对应pet_namedescribe_pet('dog', 'baby') # 二次调用 1.2.2、关键字实参位置参数固然有其优点，但只适合形参比较少的程序，若形参有很多，传递实参时就容易显得杂乱无章，关键字实参将名称与值关联起来，向形参传递实参时就不会混淆。 12345678def describe_pet(animal_type, pet_name): # 形参 """显示宠物信息""" print('\nI have a ' + animal_type + '.') print("My " + animal_type + "'s name is " + pet_name.title() + '.')describe_pet(animal_type= 'hamster', pet_name= 'harry') # 将实参直接存储到形参变量中，不管顺序如何变化都不影响结果describe_pet(pet_name= 'baby', animal_type= 'dog') 1.2.3、默认值在函数定义时可以给形参直接指定个默认值，如果与其关联的实参给有默认值的形参提供了值，则用提供的值，否则用默认值。 需要注意的是，在调用函数时，只有一个实参，且是位置实参，那么没有指定默认值的形参要在有默认值的形参前面，否则实参将会以位置参数的形式传递给第一个形参： 123456789101112131415def describe_pet(pet_name, animal_type='dogs'): # 有默认值在没有默认值的形参后面 """显示宠物信息""" print('\nI have a ' + animal_type + '.') print("My " + animal_type + "'s name is " + pet_name.title() + '.')describe_pet('willie') # 这个实参将传递给第一个形参，第二个形参使用默认值describe_pet(animal_type='dog', pet_name='baby') # 有默认值的形参使用实参-------------------I have a dogs.My dogs's name is Willie.I have a dog.My dog's name is Baby. 1.2.4、等效的函数调用鉴于可混合位置实参、关键字实参以及默认值，通常有多种调用方式，以下便是等效的函数调用方式，其结果一致： 123456789# 一只名为Willie的小狗describe_pet('willie') # 结果一致describe_pet(pet_name='willie')# 一只名为Harry的仓鼠 # 结果一致describe_pet('harry', 'hamster')describe_pet(pet_name='harry', animal_type='hamster')describe_pet(animal_type='hamster', pet_name='harry') 1.2.5、避免实参错误在使用函数时，若遇到实参不匹配时，python会提示我们需要为哪些提供实参，如果这个函数存储在一个独立的文件中，那么需要打开这个文件查看函数的代码： 12345678910def describe_pet(pet_name, animal_type): print('My ' + animal_type + "'s name is " + pet_name.title() + '.')describe_pet() # 这个函数缺少实参，python会提示我们需要为哪个形参提供实参Traceback (most recent call last): File "C:/Users/hj/PycharmProjects/untitled1/function_1.py", line 55, in &lt;module&gt; describe_pet()TypeError: describe_pet() missing 2 required positional arguments: 'pet_name' and 'animal_type' 1.3、返回值函数并非总是直接显示输出，相反，它也处理一些数据，并返回一个或一组值，返回的 值称为返回值，它可以返回列表、元组和字典，可使用return 语句将值返回到调用函数的代码行，返回值可以让你能够将程序的大部分繁重工作移到函数中去完成，从而简化程序。 1.3.1、返回简单值12345678def get_formatted_name(first_name, last_name): """返回完整姓名""" full_name = first_name + ' ' + last_name # 将完整姓名存储到变量full_name中 return full_name.title() # 将full_name的值返回到函数调用行musician = get_formatted_name('jimi', 'hendrix') # 在调用返回值的函数时，需要提供一个变量，用于存储返回值print(musician) # 打印变量------Jimi Hendrix 1.3.2、让实参变得可选有时需要让实参变得可选，这样就能存储额外的信息，可使用默认值来使实参可选： 123456789101112131415161718# 拓展get_formatted_name(),使其还处理中间名def get_formatted_name(first_name, last_name, middle_name=''): # 指定middle_name的默认值为空 """返回完整姓名""" if middle_name: # 判断调用函数时是否给middle_name指定了实参，python将非空字符串认为True full_name = first_name + ' ' + middle_name + ' ' + last_name else: full_name = first_name + ' ' + last_name return full_name.title()musician = get_formatted_name('jimi', 'hooker', 'lee')print(musician)musician = get_formatted_name('jimi', 'hooker') # 调用函数时，如果没有middle_name的实参就会导致程序错误，因此可以指定形参middle_name的默认值为空，当有实参时则用实参的值，没有的时候就是空字符串，这样不会奔溃程序print(musician)-----Jimi Lee HookerJimi Hooker 1.3.3、返回字典函数可以返回任何类型的值，包括列表、元组以及字典等较复杂的数据结构： 12345678910def build_person(first_name, last_name): """返回一个字典，其中包含有关一个人的信息""" person = &#123;'first': first_name, 'last': last_name&#125; # 也可以时列表、元组 return personmusician = build_person('jimi', 'hendrix')print(musician) # 音乐家-------&#123;'first': 'jimi', 'hendrix': 'hendrix'&#125; 返回字典，可以轻易拓展这个函数，使其接受可选值，如年龄、中间名、职业等你想存储的其他信息： 1234567891011def buile_person(first_name, last_name, age=''): # 新增了age可选项 """返回一个字典，其中包含人名、年龄""" person = &#123;'first': first_name, 'last': last_name&#125; if age: person['age'] = age # 将键-值对添加到字典person中 return personmusician = build_person('jimi', 'hendrix', age=27)print(musician)-------&#123;'first': 'jimi', 'last': 'hendrix', 'age': 27&#125; 1.3.4、结合使用函数和 while 循环1234567891011121314151617181920212223242526def get_formatted_name(first_name, last_name): """返回完整姓名""" full_name = first_name + ' ' + last_name return full_name.title()while True: print("\nTell me what's your name: ") print("(enter 'q' to quit)") # 设置循环退出条件 f_n = input('First_name: ') # 接收用户输入信息 if f_n == 'q': break l_n = input('Last_name: ') if l_n == 'q': break formatted = get_formatted_name(f_n, l_n) print('\nHello: ' + formatted + '!')--------------------Please tell me your name: (Enter 'q' to quit.)First_name: LiLast_name: LaHello Li La! 1.4、传递列表向函数传递列表，这种列表包含的可能是名字、数字或更复杂的对象（字典），将列表传递给函数后，函数就能直接访问其内容，可以提高处理列表的效率。 1.4.1、在函数中修改列表将列表传递给函数后，可以对其进行修改，修改后是永久性的，可以高效第处理大量数据。 一家为用户提交设计制作的3D打印模型公司，需要打印的设计存储在一个列表中，打印后移到另一个列表中： 123456789101112131415161718192021222324252627282930313233def printed_models(unprinted_designs, completed_models): # 定义一个函数，2个形参，一个为未打印的设计，一个为完成的模型 """ 模拟打印每个设计，直到没有未打印的为止 打印每个设计后，将其移动completed_models中 """ while unprinted_designs: # 循环（只要unprinted_designs不为空循环继续） current_design = unprited_designs.pop() # 将列表中所有元素弹出 # 模拟根据设计制作3D打印模型的过程 print('Printing model: ' + current_design) completed_models.append(current_design) # 将弹出的元素添加到空列表completed_models中 def show_completed_models(completed_models): # 定义一个函数，用以处理所有打印好的模型 """显示打印好的模型""" print('\nThe folloing models have been printed:') for completed_model in completed_models: # 遍历打印好的模型列表completed_models print(completed_model) unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron'] # 定义未打印的设计的列表completed_models = [] # 定义已经打印好的模型为空列表printed_models(unprinted_designs, completed_models) # 调用函数，将列表传递给主函数show_printed_models(completed_models)--------------Printing model: dodecahedronPrinting model: robot pendantPrinting model: iphone caseThe following models have been printed: dodecahedronrobot pendantiphone case 1.4.2、禁止函数修改列表有时需要禁止修改列表，因为修改是永久的，如上个列子，修改未打印的设计中元素，将其中的元素全部移到已经打印的模型列表中，原来的列表就变为空，为解决这个问题，可以在调用函数时，只传递列表的副本（切片）而不是原列表： 123# 在上个列子中，可以在调用函数，传递列表时，只传递列表的切片# 格式为：function_name(list_name[:])printed_models(unprinted_design[:], completed_models) 但是除非有充分理由需要保留原列表，否则尽量避免使用，因为可以使函数避免花时间去和内存去创建副本，从而提高效率，在处理大型列表尤其如此。 1.5、传递任意数量的实参有时不知需要接受多少个实参，好在python可以允许函数调用语句中收集任意数量的实参： 12345678910def make_pizza(*topping): # 形参名*topping的星号让python创建一个名为tooping的空元组，并将传递来的实参全部封装在这个元组中 """打印顾客点的所有配料""" print(topping)make_pizza('pepperoni')make_pizza('mushrooms', 'green peppers', 'extra cheese')----('pepperoni') # 封装成一个元组('mushrooms', 'green peppers', 'extra cheese') 1.5.1、结合使用位置实参和任意数量实参如果要让函数接受不同类型的实参，必须将接受任意数量的实参放置在位置参数后面，python先匹配位置和关键字实参，再匹配任意数量的实参： 123456789101112131415161718def make_pizza(size, *toppings): # 定义一个尺寸的位置形参，放在任意数量形参前 """打印顾客点的所有配料""" print('\nMaking a ' + str(size) + '-inch pizza with the following toppings: ') for topping in toppings: print('- ' + topping)make_pizza(16, 'pepperoni')make_pizza(20, 'mushrooms', 'green peppers', 'extra cheese')------------Making a 16-inch pizza with the following toppings: - pepperoniMaking a 20-inch pizza with the following toppings: - mushrooms- green peppers- extra cheese 1.5.2、使用任意数量的关键字实参有时，要接受任意数量的实参，但不知道传递给函数的会是什么信息，这种情况下，可以将函数写成能够接受任意数量的键-值对，调用语句提供了多少就接受多少： 下面列子，你将接受用户信息，但不确定什么信息，函数build_profile()接受名和姓，同时还接受任意数量的关键字实参： 1234567891011121314def build_profile(first, last, **user_info): # **user_info两个星号让python创建一个名为user_info的空字典，并将接受到所有名称-值对都封装在其中 """创建一个字典，其中包含我们知道的有关用户的一切""" profile = &#123;&#125; # 首先创建一个空字典，用以存储用户的名和姓 profile['first_name'] = first # 将名和姓添加到字典profile中 profile['last_name'] = last for key, value in user_info.items(): # 遍历user_info这个字典 profile[key] = value # 将每个键-值对添加到字典profile中 return profile # 返回字典profile到函数调用行，并把它存储到变量user_profile中user_profile = build_profile('albert', 'einstein', location='princeton', field='physics') # 传入实参（调用函数）print(user_profile) 在上面列子中，返回的字典包含了用户的名和姓，已经求学的地方和所学专业，调用这个函数时，不管额外提供了多少键-值对，它都能正确处理。 练习 编写一个函数，将一辆汽车的信息存储在一个字典中，这个函数始终接受制造商和型号，还接受关键字实参，调用这个函数，提供必不可少的信息以及两个名称-值对，如颜色、选择配件等： 1234567891011121314151617def make_car(manufacturer, model, **options): # **options接受任意数量的关键字实参，创建一个字典并将信息存储在其中 """做一个字典代表一辆车""" car_dict = &#123; # 创建一个字典能代表一辆车，其中有必不可少的 制造商型号等信息 'manufacturer': manufacturer.title(), 'model': model.title(), &#125; for option, value in options.items(): # 遍历字典options car_dict[option] = value # 将其他信息诸如颜色等添加到字典car_dict中 return car_dict # 返回car_dict字典 car = make_car('subaru', 'outback', color='blue', tow_package=True)print(car)my_car = make_car('honda', 'accord', year=1991, color='white', headlights='popup')print(my_car) 1.6、将函数存储在模块中函数可以将代码块与主程序分离，这样使程序更容易理解，还可以进一步将函数存储到独立的文件中（模块），再将模块带入主程序中，这样就可以将重点放在程序的高层逻辑上，可以与其他程序员共享这个文件而不是程序。 1.6.1、导入整个模块模块的拓展名为.py的文件，包含要导入到程序中的代码，下面来演示再另一个程序中调用第一个模块里的函数。 创建一个名为pizza.py的模块，里面包含make_pizza() 的函数，再在模块pizza.py所在目录创建一个名为making_pizza.py的文件，在这个文件中导入刚创建的模块，再调用make_pizza() 函数，调用模块中函数格式：(模块名.函数名，如pizza.make_pizza() )： 123456# pizza.py 模块def make_piza(size, *topping): # make_pizza() 函数 """概述要制作的披萨""" print('\nMaking a ' + str(size) + '-inch pizza with the following topping:') for topping in toppings: print('- ' + topping) 1234567891011# making_pizza.py 文件import pizza # 导入pizza模块pizza.make_pizza(16, 'fish') # 调用pizza.py模块中的make_pizza()函数pizza.make_pizza(20, 'egg', 'meat', 'fish') ----------------Making a 12-inch pizza with the following topping:- meat- fish- egg 1.6.2、导入特定的函数：import 只是一种导入方式，还可以导入模块中的特定函数，其格式为： 12from modul_name import function_name # from 模块名 import 函数名from modul_name import function_0, function_1, function_2 # 导入任意数量的函数 对于1.6.1的列子也可以使用这种导入方式： 123from pizza import make_pizzamake_pizza(16, 'fish') # 因为import语句显示地导入了函数名，所以调用时不需要指定其名称 1.6.3、使用 as 给函数指定别名如果要导入的函数与现有函数名有冲突，或者函数名过长，可指定别名（用以代替函数名，类似于外号），只需在导入模块时，（from modul_name import funtion_name as fn）： 123from pizza import make_pizza as mp # 给函数指定别名mp(16, 'fish') # 调用时可以使用别名 1.6.4、给模块指定别名也可以给模块指定别名，其格式为：( import module_name as mn ) 123import pizza as pp.make_pizza(16, 'fish') 1.6.5、导入模块中所有函数使用星号（*）可以让python导入模块中的所有函数，其格式为： from modul_name import * 在大型模块中，最好不要采用这种导入方式，如果模块中有函数的名称与你的项目有相同的，可能导致意想不到的结果，python处置名称相同的函数或者变量时，会进行覆盖，最佳做法是，只导入需要的函数，要么整个模块并使用句点表示法（即modul_name.function_name() ）。 1.7、函数编写指南 函数名，应取具有描述性的名称（即与实现函数功能相关的名称），使用小写字母与下划线，模块名亦如此，这样便于理解。 每个函数应有注释，紧跟函数定义后面，采用文档字符串格式。 给形参指定默认值时，等号两边不用有空格，实参亦如此。 PEP 8 建议代码行长度不超过79个字符，如果形参很多，超过79个字符，可以在函数定义时输入左括号后按回车键，并在下一行按两次Tab键，实质上多数编辑器都能自动实现参数对齐，如下： 12345def function_name( parameter_0, parameter_1, parameter_2, parameter_3, parameter_4, parameter_5 ): 如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一个函数在哪结束，下一个函数在哪开始。 所有的import 语句都应在开头，唯一的列外的情形时，在文件开头使用了注释来描述整个程序。]]></content>
      <categories>
        <category>Python 基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>函数</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo blog]]></title>
    <url>%2F2017%2F10%2F10%2Fhexo-blog-1%2F</url>
    <content type="text"><![CDATA[1、hexo是什么：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。hexo官网 2、搭建流程： 配置搭建环境（含node.js、Git和github账户的申请配置） 安装hexo 配置hexo 将hexo与github page联系起来 发布文章 主题配置 博客优化 绑定域名 3、node.js 安装Windows Installer 64-bit Windows Installer 32-bit 一路保持默认即可，安装结束后，检查组件是否安装好，同时按win（windows键）+R键，输入cmd（或者在开始输入CMD，右键管理员允许），打开命令窗口。windows运行界面 在命令窗口输入 12node -vnpm -v 结果如下图，则表示node.js安装成功 4、 安装Git： Git官网地址 安装默认即可，要注意的是在选择PATH选项时，建议按照下图选择，这样会使得Git在安装的时候会在系统PATH中加入Git的路径，可以直接调用CMD。 检查安装是否正确，输入以下命令： 1git --version 5、github账户注册和配置： 官网地址 输入自己的用户名、邮箱、密码，注册完毕后，一定要去自己注册的邮箱中确认，否则不能使用gh-page。 创建代码库： 登录进去后，点击右上角的+号，选择New repository： Repository name（仓库名字）一定要填与自己github账户名一样的名字，不然后续会有些麻烦，此处因为我已经创建了。 代码库设置 进入你的仓库后，选择setting，如下图所示： 下拉找到Github Pages，找到Source，选择master branch，再点击save保存，过一会会生成一个github pages网址。 6、 安装配置hexo： 安装hexo 打开git brash或者cmd控制台 安装hexo依赖 1npm install -g hexo-cli 安装install 组件 1npm install hexo --save 查看版本 1hexo -v` 如下图所示，则表示安装成功 配置hexo hexo初始化 使用命令切换到你需要存放本地仓库的磁盘，然后在磁盘根目录新建文件夹（本地仓库）。假如你在E盘根目录新建一个文件夹（**此处文件夹名必须和你的github新建的仓库名（Repository name）一致） 12345E: #切换到E盘hexo init xx.github.io #新建本地仓库 ``` 初始化完毕后，在E盘根目录会看到一个xx.github.io的文件夹，这就是你的本地仓库。 安装npm包 1npm install 生成 1hexo g #hexo g 是hexo generate的简写``` 启动服务预览 12hexo s #hexo s 是hexo server的简写``` hexo s -g 当完成上述操作后提示如下，即可访问http:localhost:4000/ 1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 填坑 理论上到此处就可以访问http:localhost:4000/，但是事与愿违，4000端口往往被占用，导致不能访问，不过官方也给出了解决方法:https://hexo.io/zh-cn/docs/server.html#自定义-IP hexo3.0后的版本，由于服务器是独立成个别模块，所以首先需要安装hexo-server 1npm install hexo-server –save 安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。 1hexo server hexo server 1hexo server -p 5000 #更改为5000端口 在浏览器输入http:localhost:5000/即可访问 7、将hexo和github关联起来： 配置git个人信息： 第一次使用git的话，需要配置用户名与邮箱地址：12git config --global user.name &quot;XXX&quot;git config --global user.email &quot;XXX@XXXcom&quot; 检查是否有SSH，没有的话需要在github新建12cd ~/.ssh #检查ls #查看 如果有的话，会有两个文件，如下图： 生成新的密钥 1ssh-keygen -t rsa -C &quot;XXX@XXXcom&quot; 将SSH Key 添加到ssh-agent 1eval $(ssh-agent -s) 查看SSH返回路径 1ssh-add ~/.ssh/id_rsa 添加成功，会返回路径1Identity added: /c/User/Administator/.ssh/id_rsa (/c/Users/Administator/.ssh/id_rsa) 根据地址找到这两个文件 把SSH添加到github上 打开github，右上角选择setting，再选择SSH and GPG keys，选择New SSH key（添加SSH key），将id_rsa.pub的文件拷贝到key中，最后Add SSH key即可。 验证SSH 1ssh -T git@github.com 配置Deployment 找到本地仓库（xx.github.io）,打开找到_config.yml文件，（建议使用Notepad++编辑），再找到deploy，配置如下：git@github.com都是一致的，后面的则分别是github帐户名、仓库名图上coding地址为使用coding加速后才添加的，此处可不添加修改完毕后保存，并使用命令保存，否则报错：1npm install hexo-deployer-git --save 8、发布文章 ： 新建一篇名为article title的博客： 1hexo new post &quot;article title&quot; 在我的电脑的目录下 E:\xx.github.io\source\ _posts 将会看到 article title.md 文件（打开.md文件，windows推荐使用markdownpad2） 生成部署： 1234hexo clean hexo g #生成hexo d #部署 hexo d -g #也可以只有一步，在部署前先生成 部署完毕后即可访问博客：https://xx.github.io/ 9、主题配置： 详情请见这篇文章：NexT主题配置 10、博客优化：由于诸多原因导致国内访问github速度很慢，有时更新一篇博客，或者改动一些配置，需要很长时间才能加载出来，所以我们可以对博客进行一些优化，提高加载速度。详情请见下面这篇文章： http://www.jianshu.com/p/414ca84237ea 11、绑定域名：一般使用hexo搭建博客后，博客地址大多为：https://xx.github.io之类，一来是不好听没有个性，二来是不方便管理，三是速度慢。 购买域名 比如国外的：godaddy、Name等；国内的：或新网、万网、耐思尼克……我是选择的阿里云（万网），以下介绍的也是阿里云的域名：输入你 想要的域名，选择未注册的域名，有不同的套餐，一年几年。 域名解析 首先需要进行域名实名认证，未认证不能使用，图中域名状态显示未认证，实名认证很简单在这不多赘述 点击解析，进行解析： 点击添加解析，添加两个A记录类型，主机记录都为@，线路默认，记录值为github提供的2个ip：（192.30.252.153、192.30.252.154），再添加一个CNAME类型，主机记录为www，记录值为你的博客地址xx.github.io，最后保存即可。 创建CNAME文件 上述设置完毕后，在本地仓库xx.github.io目录下的source文件夹中新建CNAME文件，不带任何后缀名，然后再其中放入你的域名地址（xxxx.com），最好写xxx.com而不是www.xxxx.com，这样使用xxx.com或者www.xxx.com都可以访问。 至此博客算是搭建完毕，这只能算是一个比较粗略的博客，还有很多需要去配置改进的；我查阅了不下十篇文章，其中坑太多，新手容易入坑，为此我把一些该注意的都列举出来，以防止掉坑里。 参考文章：hexo入门学习（五）：绑定独立域名少撸两局教你搭个博客玩手把手教你用Hexo+Github 搭建属于自己的博客]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换电脑后hexo博客的搭建]]></title>
    <url>%2F2017%2F10%2F10%2Fchange%2F</url>
    <content type="text"><![CDATA[1、必须拷贝的文件更换电脑后，要想使用hexo搭建的博客，必须在新电脑上搭建hexo环境，大概分为以下几个步骤： 拷贝原有电脑本地仓库到新电脑 新电脑上搭建hexo环境 组件安装 部署执行完成 必须将你原来电脑上已经配置好并生成的hexo目录拷到你的新电脑上，注意无需拷全部，只拷如下几个目录： _config.ymlpackage.jsonscaffolds/source/themes/ 2、新电脑搭建hexo环境 安装git，安装node.js 打开git bash，输入npm install hexo-cli -g，安装hexo 将原来的文件拷贝到新电脑某个目录下 切换到新目录下，使用npm install命令进行模块安装（不能使用hexo init对hexo初始化） 3、组件安装npm install hexo-deployer-git --save 为了使用hexo d来部署到git上 npm install hexo-generator-feed --save 为了建立RSS订阅 pm install hexo-generator-sitemap --save 为了建立站点地图 插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明 4、部署完成git bash窗口输入hexo g，再使用hexo d进行部署即可 5、添加ssh 打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “youremail@example.com” 把其中的邮件地址换成自己的邮件地址，然后一路回车 最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。 注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F10%2F07%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[title: hexo 博客搭建date: 2017-10-07 21:54:15tags: hexo blog git githubcategories: 博客搭建 1、hexo是什么：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。hexo官网 2、搭建流程： 配置搭建环境（含node.js、Git和github账户的申请配置） 安装hexo 配置hexo 将hexo与github page联系起来 发布文章 主题配置 博客优化 绑定域名 3、node.js 安装12345678910111213141516171819202122232425262728[Windows Installer 64-bit](https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi) [Windows Installer 32-bit](https://nodejs.org/dist/v4.2.3/node-v4.2.3-x86.msi)``` 一路保持默认即可，安装结束后，检查组件是否安装好，同时按win（windows键）+R键，输入cmd（或者在开始输入CMD，右键管理员允许），打开命令窗口。 windows运行界面 ![](http://upload-images.jianshu.io/upload_images/4209226-baa0d92e8171efaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 在命令窗口输入 ``` node -v npm -v ``` 结果如下图，则表示node.js安装成功 ![](http://upload-images.jianshu.io/upload_images/4209226-bbd2482a705e5094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) # 4、 安装Git： &gt; [Git官网地址](https://git-scm.com/downloads )安装默认即可，要注意的是在选择PATH选项时，建议按照下图选择，这样会使得Git在安装的时候会在系统PATH中加入Git的路径，可以直接调用CMD。 ![](http://upload-images.jianshu.io/upload_images/4209226-1f5aca1e08b652f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)检查安装是否正确，输入以下命令： git –version12345678910111213141516171819202122232425262728293031323334353637383940414243![](http://upload-images.jianshu.io/upload_images/4209226-0d1a4891a27a2516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) # 5、github账户注册和配置：&gt; [官网地址](https://github.com/)输入自己的用户名、邮箱、密码，注册完毕后，一定要去自己注册的邮箱中确认，否则不能使用gh-page。 &gt; 创建代码库： 登录进去后，点击右上角的+号，选择New repository： ![](http://upload-images.jianshu.io/upload_images/4209226-3b18ee9a2345b932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) Repository name（仓库名字）一定要填与自己github账户名一样的名字，不然后续会有些麻烦，此处因为我已经创建了。 ![](http://upload-images.jianshu.io/upload_images/4209226-94ef38a62b1d0e74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) &gt; 代码库设置 进入你的仓库后，选择setting，如下图所示： ![](http://upload-images.jianshu.io/upload_images/4209226-62f4ed7e3f3d4953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 下拉找到Github Pages，找到Source，选择master branch，再点击save保存，过一会会生成一个github pages网址。 ![](http://upload-images.jianshu.io/upload_images/4209226-be4a215f803ca991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) # 6、 安装配置hexo： &gt; 安装hexo打开git brash或者cmd控制台+ 安装hexo依赖 ``` npm install -g hexo-cli``` + 安装install 组件 ``` npm install hexo --save ``` + 查看版本 hexo -v1234567891011121314151617181920如下图所示，则表示安装成功 ![](http://upload-images.jianshu.io/upload_images/4209226-5c7f26fad73a622e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) &gt; **配置hexo** + hexo初始化使用命令切换到你需要存放本地仓库的磁盘，然后在磁盘根目录新建文件夹（本地仓库）。假如你在E盘根目录新建一个文件夹（**此处文件夹名必须和你的github新建的仓库名（Repository name）一致）``` E: #切换到E盘hexo init xx.github.io #新建本地仓库 ``` 初始化完毕后，在E盘根目录会看到一个xx.github.io的文件夹，这就是你的本地仓库。 + 安装npm包 ``` npm install 生成 1234567hexo g #hexo g 是hexo generate的简写 ``` + 启动服务预览 ``` hexo s #hexo s 是hexo server的简写 上述也可以写成123456789101112131415161718hexo s -g ``` 当完成上述操作后提示如下，即可访问http:localhost:4000/ ``` INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. ``` &gt; **填坑** 理论上到此处就可以访问http:localhost:4000/，但是事与愿违，4000端口往往被占用，导致不能访问，不过官方也给出了解决方法:https://hexo.io/zh-cn/docs/server.html#自定义-IP hexo3.0后的版本，由于服务器是独立成个别模块，所以首先需要安装hexo-server ``` npm install hexo-server --save``` 安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。 ``` hexo server 再更改端口 hexo server -p 5000 #更改为5000端口 在浏览器输入http:localhost:5000/即可访问 7、将hexo和github关联起来： 配置git个人信息： 第一次使用git的话，需要配置用户名与邮箱地址： git config --global user.name &quot;XXX&quot; git config --global user.email &quot;XXX@XXXcom&quot; 检查是否有SSH，没有的话需要在github新建 cd ~/.ssh #检查 ls #查看 如果有的话，会有两个文件，如下图： 生成新的密钥 ssh-keygen -t rsa -C &quot;XXX@XXXcom&quot; 将SSH Key 添加到ssh-agent eval $(ssh-agent -s) 查看SSH返回路径 ssh-add ~/.ssh/id_rsa 添加成功，会返回路径 Identity added: /c/User/Administator/.ssh/id_rsa (/c/Users/Administator/.ssh/id_rsa) 根据地址找到这两个文件 把SSH添加到github上 打开github，右上角选择setting，再选择SSH and GPG keys，选择New SSH key（添加SSH key），将id_rsa.pub的文件拷贝到key中，最后Add SSH key即可。 验证SSH ssh -T git@github.com 配置Deployment 找到本地仓库（xx.github.io）,打开找到_config.yml文件，（建议使用Notepad++编辑），再找到deploy，配置如下：git@github.com都是一致的，后面的则分别是github帐户名、仓库名图上coding地址为使用coding加速后才添加的，此处可不添加修改完毕后保存，并使用命令保存，否则报错： npm install hexo-deployer-git --save 8、发布文章 ： 新建一篇名为article title的博客： hexo new post &quot;article title&quot; 在我的电脑的目录下 E:\xx.github.io\source\ _posts 将会看到 article title.md 文件（打开.md文件，windows推荐使用markdownpad2） 生成部署： hexo clean hexo g #生成 hexo d #部署 hexo d -g #也可以只有一步，在部署前先生成 部署完毕后即可访问博客：https://xx.github.io/ 9、主题配置： 详情请见这篇文章：NexT主题配置 10、博客优化：由于诸多原因导致国内访问github速度很慢，有时更新一篇博客，或者改动一些配置，需要很长时间才能加载出来，所以我们可以对博客进行一些优化，提高加载速度。详情请见下面这篇文章： http://www.jianshu.com/p/414ca84237ea 11、绑定域名：一般使用hexo搭建博客后，博客地址大多为：https://xx.github.io之类，一来是不好听没有个性，二来是不方便管理，三是速度慢。 购买域名 比如国外的：godaddy、Name等；国内的：或新网、万网、耐思尼克……我是选择的阿里云（万网），以下介绍的也是阿里云的域名：输入你 想要的域名，选择未注册的域名，有不同的套餐，一年几年。 域名解析 首先需要进行域名实名认证，未认证不能使用，图中域名状态显示未认证，实名认证很简单在这不多赘述 点击解析，进行解析： 点击添加解析，添加两个A记录类型，主机记录都为@，线路默认，记录值为github提供的2个ip：（192.30.252.153、192.30.252.154），再添加一个CNAME类型，主机记录为www，记录值为你的博客地址xx.github.io，最后保存即可。 创建CNAME文件 上述设置完毕后，在本地仓库xx.github.io目录下的source文件夹中新建CNAME文件，不带任何后缀名，然后再其中放入你的域名地址（xxxx.com），最好写xxx.com而不是www.xxxx.com，这样使用xxx.com或者www.xxx.com都可以访问。 至此博客算是搭建完毕，这只能算是一个比较粗略的博客，还有很多需要去配置改进的；我查阅了不下十篇文章，其中坑太多，新手容易入坑，为此我把一些该注意的都列举出来，以防止掉坑里。 参考文章：hexo入门学习（五）：绑定独立域名少撸两局教你搭个博客玩手把手教你用Hexo+Github 搭建属于自己的博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[test1]]></title>
    <url>%2F2017%2F09%2F20%2Ftest1%2F</url>
    <content type="text"></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test1</tag>
        <tag>one</tag>
        <tag>two</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2017%2F09%2F19%2Ftest%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
